<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>efficient on Int Maker</title>
    <link>https://intmaker.com/tags/efficient/</link>
    <description>Recent content in efficient on Int Maker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 18 Feb 2015 22:11:26 +0000</lastBuildDate>
    
	<atom:link href="https://intmaker.com/tags/efficient/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>.NET String Dictionary vs string switch performance</title>
      <link>https://intmaker.com/2015/net-string-dictionary-vs-string-switch-performance/</link>
      <pubDate>Wed, 18 Feb 2015 22:11:26 +0000</pubDate>
      
      <guid>https://intmaker.com/2015/net-string-dictionary-vs-string-switch-performance/</guid>
      <description>&lt;p&gt;I had a simple task to map a collection of objects with string property. Map function should replace one string property to another from set of 5-6 strings. Existing solution used Dictionary initialized with those hard-coded values. Once upon a time I tried to compare Dictionary with &lt;em&gt;int&lt;/em&gt; keys to &lt;em&gt;int&lt;/em&gt; switch and int switch was FAR better. It was chess engine so performance mattered.&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s a web request with thousands of rows of reply, serialized to json, so performance matters again. I wrote simple program, which generated 10 million instances of my simple class with several properties and mapped this list with both methods. Before that I ensured that both methods were JIT&amp;rsquo;ed. You can find &lt;a href=&#34;https://github.com/Ribtoks/heap/blob/master/PerformanceTests/StringSwitchTest/StringSwitchTest/Program.cs&#34; target=&#34;_blank&#34;&gt;source code at Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Details below..&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>